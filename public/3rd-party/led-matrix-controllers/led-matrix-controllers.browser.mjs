const t=9,e=34,a=12972,r=[50,172],i=32,n=[0,32],s=Object.freeze([0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,5,5,5,5,6,6,6,6,6,7,7,7,7,8,8,8,9,9,9,10,10,10,11,11,11,12,12,12,13,13,14,14,14,15,15,16,16,17,17,17,18,18,19,19,20,20,21,22,22,23,23,24,24,25,26,26,27,27,28,29,29,30,31,32,32,33,34,34,35,36,37,38,38,39,40,41,42,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,66,67,68,69,70,71,73,74,75,76,78,79,80,82,83,84,86,87,88,90,91,93,94,96,97,99,100,102,103,105,106,108,110,111,113,115,116,118,120,121,123,125,127,128,130,132,134,136,138,140,141,143,145,147,149,151,153,155,157,159,161,164,166,168,170,172,174,177,179,181,183,186,188,190,193,195,197,200,202,205,207,210,212,215,217,220,222,225,228,230,233,236,238,241,244,247,249,252,255]),o=[{usbVendorId:a,usbProductId:32}];class c extends Error{constructor(){super("User cancelled port selection."),this.name=this.constructor.name,this.date=new Date}}class u extends Error{constructor(){super("Selected port already in use."),this.name=this.constructor.name,this.date=new Date}}async function l(){try{return navigator.serial.requestPort?await navigator.serial.requestPort({filters:o}):null}catch(t){switch(t.name){case"NotFoundError":throw new c;case"InvalidStateError":throw new u;case"SecurityError":return null;default:throw t}}}const d=new class{used=new Set;unused=[];async getOrFetchUnused(){let t=this.unused.pop();if(!t){const e=await navigator.serial.getPorts({filters:o});this.#t(e),t=this.unused.pop()}if(!t){const e=await l();this.#t([e]),t=this.unused.pop()}return t&&this.used.add(t),t}#t(t){if(t)for(const e of t)!e||this.used.has(e)||this.unused.includes(e)||this.unused.push(e)}};async function w(){await l()}async function h(){return await d.getOrFetchUnused()}async function p(t){try{await t.close()}catch(t){if("InvalidStateError"!=t.name&&t.message.includes("The port is already closed"))throw t}}class y{constructor(t){this.#e=`port-mutex-${Math.random().toString()}`,this.#a=new Map,this.#r=t}async acquire(t){const e=new Error("created bad cb").stack;await this.#i(async()=>{try{await t(this.#r)}catch(t){console.error("Error occured in anonymous callback."),console.error("Original error:",t),console.error("--- This callback was created at ---\n",e)}})}async acquireIdempotent(t,e){const a=new Error("created bad cb").stack;this.#a.has(t)&&console.info(`"${t}" request coalesced.`),this.#a.set(t,async()=>{try{await e(this.#r)}catch(t){console.error("Error occured in anonymous callback."),console.error("Original error:",t),console.error("--- This callback was created at ---\n",a)}}),await this.#i(()=>this.#n(t))}async#i(t){return navigator.locks.request(this.#e,t)}async#n(t){if(this.#a.has(t)){const e=this.#a.get(t);this.#a.delete(t),await e()}}#e;#a;#r}class f{constructor(t){this.#s=t}async rx(t,e=3e3){if(null===this.#s)throw new Error("attempted RX before port initialization.");if(this.#s.readable.locked)throw new Error("attempted RX while port locked.");const a=[],r=this.#s.readable.getReader(),i=setTimeout(()=>r.cancel(),e);try{for(;a.length<t;){const{value:t,done:e}=await r.read();if(a.push(...t??[]),e||!t)break}}finally{clearTimeout(i),r.releaseLock()}return a}async tx(t){if(null===this.#s)throw new Error("attempted TX before port initialization.");if(this.#s.writable.locked)throw new Error("attempted TX while port locked.");const e=this.#s.writable.getWriter();try{await e.write(new Uint8Array(t))}finally{await e.close()}}#s}const E=Object.freeze({ANIMATE:4,BRIGHTNESS:0,BOOTLOADER:2,DRAW:6,DRAW_GREY_COL_BUFFER:8,GAME_CTRL:17,GAME_STATUS:18,PANIC:5,PATTERN:1,SLEEP:3,STAGE_GREY_COL:7,START_GAME:16,VERSION:32}),_=Object.freeze({GRAY_8BIT:"8-bit",MONO_1BIT:"1-bit"});let x=class{constructor(t=null){this.portMutex=t}async bootloader(){await this.portMutex.acquire(async t=>{await t.tx([...r,E.BOOTLOADER])})}async brightness(t){await this.portMutex.acquire(async e=>{await e.tx([...r,E.BRIGHTNESS,t])})}async draw(t){let e=0,a=new Uint8Array(39).fill(0);for(let r=0;r<34;r++)for(let i=0;i<9;i++)t[r][i]&&(a[e>>3]|=1<<e%8),e++;await this.portMutex.acquireIdempotent("drawMatrix",async t=>{await t.tx([...r,E.DRAW,...a])})}async drawGrayscale(t){const e=Array.from({length:9},(e,a)=>Array.from({length:34},(e,r)=>s[Math.floor(255*(t[r][a]??0))]));await this.portMutex.acquireIdempotent("drawMatrix",async t=>{for(let a=0;a<9;a++)await t.tx([...r,E.STAGE_GREY_COL,a,...e[a]]);await t.tx([...r,E.DRAW_GREY_COL_BUFFER])})}async asleep(){let t=!1;return await this.portMutex.acquire(async e=>{await e.tx([...r,E.SLEEP]),t=await e.rx(32),t=0!=t[0]}),t}async sleep(){await this.portMutex.acquire(async t=>{await t.tx([...r,E.SLEEP,1])})}async wake(){await this.portMutex.acquire(async t=>{await t.tx([...r,E.SLEEP])})}async pattern(t){await this.portMutex.acquireIdempotent("drawMatrix",async e=>{await e.tx([...r,E.PATTERN,t])})}async percent(t){await this.portMutex.acquireIdempotent("drawMatrix",async e=>{await e.tx([...r,E.PATTERN,Pattern.PERCENTAGE,t])})}async version(){let t={};return await this.portMutex.acquire(async e=>{await e.tx([...r,E.VERSION]);const a=await e.rx(32);t.major=a[0],t.minor=a[1]>>4,t.patch=15&a[1],t.preRelease=1==a[2]}),t}};class m extends x{async bootloader(){await super.bootloader()}async connect(){const t=await h();if(!t?.connected)throw new Error("No Port Found");await p(t),await t.open({baudRate:115200}),this.portMutex=new y(new f(t))}async draw(t){switch(this.bitDepth??_.MONO_1BIT){case _.GRAY_8BIT:await super.drawGrayscale(t);break;case _.MONO_1BIT:await super.draw(t);break;default:console.error(`Unsupported bitdepth: ${this.bitDepth}`)}}async verifyFirmware(){try{const t=await super.version();return t&&null!=t.major&&null!=t.minor&&null!=t.patch&&null!=t.preRelease}catch{return!1}}async version(){return super.version()}}const A=Object.freeze({NOOP:0,ANIMATION_DIAMOND:100,ANIMATION_FIRE:98,ANIMATION_FIREPLACE:102,ANIMATION_GEAR:103,ANIMATION_RING:114,ANIMATION_STARTUP:97,ANIMATION_STARTUP_ONCE:65,BOOTLOADER:101,DRAW_PWM:109,DRAW_PWM_BLOCKING:77,DRAW_SCALE:110,DRAW_SCALE_BLOCKING:78,FLUSH_CMD_QUEUE:99,TEST_PATTERN:116,SET_CONST_PWM:119,SET_CONST_SCALE:115,SET_PX_PWM:112,SET_PX_SCALE:113,IDENTITY_STRING:127}),T=/^Sig\sFW\sLED\sMatrix\sFW\sV(\d+)\.(\d+)$/;class b{constructor(t=null){this.portMutex=t}async bootloader(){await this.portMutex.acquire(async t=>{await t.tx([A.BOOTLOADER])})}async identityString(){let t=null;return await this.portMutex.acquire(async e=>{await e.tx([A.IDENTITY_STRING]),t=await e.rx(25)}),String.fromCharCode(...t)}async setPixelPwm(t,e,a){await this.portMutex.acquire(async r=>{await r.tx([A.SET_PX_PWM,e,t,a])})}async setGlobalPwm(t){await this.portMutex.acquire(async e=>{await e.tx([A.SET_CONST_PWM,t])})}async setMatrixPwm(t){await this.portMutex.acquireIdempotent("drawMatrix",async e=>{await e.tx([A.DRAW_PWM].concat(t.flat().map(t=>s[Math.floor(255*(t??0))])))})}async setPixelAnalog(t,e,a){await this.portMutex.acquire(async r=>{await r.tx([A.SET_PX_SCALE,e,t,a])})}async setGlobalAnalog(t){await this.portMutex.acquire(async e=>{await e.tx([A.SET_CONST_SCALE,t])})}async setMatrixAnalog(t){await this.portMutex.acquireIdempotent("drawMatrix",async e=>{await e.tx([A.DRAW_SCALE].concat(t.flat().map(t=>s[Math.floor(255*(t??0))])))})}}class g extends b{async bootloader(){await super.bootloader()}async connect(){const t=await h();t?.connected&&(await p(t),await t.open({baudRate:115200}),this.portMutex=new y(new f(t)))}async draw(t){if(this.#o)throw new Error("No Port Found");await super.setGlobalAnalog(32),this.#o=!0,await super.setMatrixPwm(t)}async verifyFirmware(){return null!=await this.version()}async version(){const t=(await super.identityString()).match(T);return t&&3==t.length?{major:t[1],minor:t[2]}:null}#o}const M=[{vendorId:a,productId:32}];class v extends Error{constructor(){super("User cancelled device selection."),this.name=this.constructor.name,this.date=new Date}}async function S(){try{return navigator.serial.requestPort?await navigator.serial.requestDevice({filters:M}):null}catch(t){switch(t.name){case"NotFoundError":throw new v;case"SecurityError":return null;default:throw t}}}const O=new class{used=new Set;unused=[];async getOrFetchUnused(){let t=this.unused.pop();if(!t){const e=await navigator.hid.getDevices({filters:M});this.#t(e),t=this.unused.pop()}if(!t){const e=await S();this.#t([e]),t=this.unused.pop()}return t&&this.used.add(t),t}#t(t){if(t)for(const e of t)!e||this.used.has(e)||this.unused.includes(e)||this.unused.push(e)}};async function I(){await S()}async function R(){return await O.getOrFetchUnused()}class N{constructor(t){this.#c=t}async send(t,e){if(e.length<t.bytes)e=function(t,e,a=0){return t.concat(new Array(e-t.length).fill(a))}(e,t.bytes);else if(e.length>t.bytes)throw new Error("Unable to send report: too many bytes");const a=new Uint8Array(e).buffer;t.feature?await this.#c.sendFeatureReport(t.id,a):await this.#c.sendReport(t.id,a)}async request(t){let e=[];if(!t.feature)throw new Error("Invalid operation");if(e=await this.#c.receiveFeatureReport(t.id),e.byteLength!=t.bytes){const a=t.bytes,r=e.byteLength;console.error(`reply length=${r} (expected ${a})`)}return e}#c}const q={id:1,bytes:307,feature:!0},U={id:2,bytes:16,feature:!0},P={id:4,bytes:306,feature:!0},D=0,L=1,F=2,C=3,G=5,k=0;class W{constructor(t=null){this.device=t}async info(){const t=await this.device.request(q);return{sleep_pin:t.getUint8(1),dip1_pin:t.getUint8(2),intb_pin:t.getUint8(3),state_flags:t.getUint8(4),id_reg:t.getUint8(5),config_reg:t.getUint8(6),global_brightness:t.getUint8(7),display_width:t.getUint8(8),display_height:t.getUint8(9),timeout_ms:t.getUint32(10),version_major:t.getUint8(14),version_minor:t.getUint8(15)}}async wake(){await this.device.send(U,[L,!1])}async sleep(){await this.device.send(U,[L,!0])}async disableSleep(){await this.device.send(U,[C,255,255,255,255])}async disableDeepSleep(){await this.device.send(U,[F,1])}async disableSleepTimer(){await this.device.send(U,[C,0,0,0,0])}async enableDeepSleep(){await this.device.send(U,[F,0])}async enableSleepTimer(t){const e=new DataView(new ArrayBuffer(4));e.setInt32(0,t,!1),await this.device.send(U,[C,e.getUint8(0),e.getUint8(1),e.getUint8(2),e.getUint8(3)])}async reboot(t){await this.device.send(U,[D,t])}async drawMatrix(t){await this.device.send(P,t.flat().map(t=>s[Math.floor(255*(t??0))]))}async drawPixel(t,e,a){await this.device.send(U,[G,e,t,a])}async drawLine({r1:t,c1:e},{r2:a,c2:r},i){await this.device.send(U,[G,t,e,a,r,i])}device}class B extends W{async bootloader(){await super.reboot(k)}async connect(){const t=await R();if(!t)throw new Error("No Device Found");await t.open(),this.device=new N(t)}async draw(t){await super.drawMatrix(t)}async verifyFirmware(){try{const t=await super.info();return 34==t.display_height&&9==t.display_width}catch{return!1}}async version(){const t=await super.info();return null!=t.version_major&&null!=t.version_minor&&(t.version_major>0||t.version_minor>0)?{major:t.version_major,minor:t.version_minor}:{major:1,minor:0}}}class j{static async detectSerial(){const t=new m,e=new g;return await t.connect(),await t.verifyFirmware()?t:(await e.connect(),await e.verifyFirmware()?e:null)}static async detectHID(){const t=new B;return await t.connect(),await t.verifyFirmware()?t:null}}export{m as DefaultController,v as DeviceSelectionCancelled,s as GAMMA,e as HEIGHT,j as HardwareControllerFactory,i as PID,n as PID_ARR,c as PortSelectionCancelled,u as PortUnavailable,g as SigrootController,B as SparkleController,a as VID,r as VID_ARR,t as WIDTH,p as close,R as getUnusedDevice,h as getUnusedPort,I as reqestDeviceForWorker,w as requestPortForWorker};
//# sourceMappingURL=led-matrix-controllers.browser.mjs.map
